/*
 * SIRIUS Nightsky API
 * REST API that provides the full functionality of SIRIUS and its web services as background service. It is intended as entry-point for scripting languages and software integration SDKs.This API is exposed by SIRIUS 6.0.0-SNAPSHOT
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package de.unijena.bioinf.ms.nightsky.sdk.api;

import de.unijena.bioinf.ms.nightsky.sdk.client.ApiClient;
import de.unijena.bioinf.ms.nightsky.sdk.client.ApiException;
import de.unijena.bioinf.ms.nightsky.sdk.client.ApiResponse;
import de.unijena.bioinf.ms.nightsky.sdk.client.Pair;

import de.unijena.bioinf.ms.nightsky.sdk.model.ImportLocalFilesSubmission;
import de.unijena.bioinf.ms.nightsky.sdk.model.ImportStringSubmission;
import de.unijena.bioinf.ms.nightsky.sdk.model.Job;
import de.unijena.bioinf.ms.nightsky.sdk.model.JobOptField;
import de.unijena.bioinf.ms.nightsky.sdk.model.JobSubmission;
import de.unijena.bioinf.ms.nightsky.sdk.model.PageJob;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-11-11T15:12:24.554845061+01:00[Europe/Berlin]")
public class JobsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public JobsApi() {
    this(new ApiClient());
  }

  public JobsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Delete job.
   * Delete job. Specify how to behave for running jobs.
   * @param projectId project-space to run jobs on (required)
   * @param jobId of the job to be deleted (required)
   * @param cancelIfRunning If true job will be canceled if it is not finished. Otherwise,                         deletion will fail for running jobs or request will block until job has finished. (optional, default to true)
   * @param awaitDeletion If true request will block until deletion succeeded or failed.                         If the job is still running the request will wait until the job has finished. (optional, default to true)
   * @throws ApiException if fails to make API call
   */
  public void deleteJob(String projectId, String jobId, Boolean cancelIfRunning, Boolean awaitDeletion) throws ApiException {
    deleteJobWithHttpInfo(projectId, jobId, cancelIfRunning, awaitDeletion);
  }

  /**
   * Delete job.
   * Delete job. Specify how to behave for running jobs.
   * @param projectId project-space to run jobs on (required)
   * @param jobId of the job to be deleted (required)
   * @param cancelIfRunning If true job will be canceled if it is not finished. Otherwise,                         deletion will fail for running jobs or request will block until job has finished. (optional, default to true)
   * @param awaitDeletion If true request will block until deletion succeeded or failed.                         If the job is still running the request will wait until the job has finished. (optional, default to true)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteJobWithHttpInfo(String projectId, String jobId, Boolean cancelIfRunning, Boolean awaitDeletion) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteJobRequestBuilder(projectId, jobId, cancelIfRunning, awaitDeletion);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteJob", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteJobRequestBuilder(String projectId, String jobId, Boolean cancelIfRunning, Boolean awaitDeletion) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling deleteJob");
    }
    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      throw new ApiException(400, "Missing the required parameter 'jobId' when calling deleteJob");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/projects/{projectId}/jobs/{jobId}"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()))
        .replace("{jobId}", ApiClient.urlEncode(jobId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "cancelIfRunning";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cancelIfRunning", cancelIfRunning));
    localVarQueryParameterBaseName = "awaitDeletion";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("awaitDeletion", awaitDeletion));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Delete job configuration with given name.
   * Delete job configuration with given name.
   * @param name name of the job-config to delete (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteJobConfig(String name) throws ApiException {
    deleteJobConfigWithHttpInfo(name);
  }

  /**
   * Delete job configuration with given name.
   * Delete job configuration with given name.
   * @param name name of the job-config to delete (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteJobConfigWithHttpInfo(String name) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteJobConfigRequestBuilder(name);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteJobConfig", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteJobConfigRequestBuilder(String name) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling deleteJobConfig");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/job-configs/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Request default job configuration
   * Request default job configuration
   * @param includeConfigMap if true, generic configmap with-defaults will be included (optional, default to false)
   * @return JobSubmission
   * @throws ApiException if fails to make API call
   */
  public JobSubmission getDefaultJobConfig(Boolean includeConfigMap) throws ApiException {
    ApiResponse<JobSubmission> localVarResponse = getDefaultJobConfigWithHttpInfo(includeConfigMap);
    return localVarResponse.getData();
  }

  /**
   * Request default job configuration
   * Request default job configuration
   * @param includeConfigMap if true, generic configmap with-defaults will be included (optional, default to false)
   * @return ApiResponse&lt;JobSubmission&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<JobSubmission> getDefaultJobConfigWithHttpInfo(Boolean includeConfigMap) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getDefaultJobConfigRequestBuilder(includeConfigMap);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getDefaultJobConfig", localVarResponse);
        }
        return new ApiResponse<JobSubmission>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<JobSubmission>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getDefaultJobConfigRequestBuilder(Boolean includeConfigMap) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/default-job-config";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "includeConfigMap";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("includeConfigMap", includeConfigMap));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get job information and its current state and progress (if available).
   * Get job information and its current state and progress (if available).
   * @param projectId project-space to run jobs on (required)
   * @param jobId of the job to be returned (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return Job
   * @throws ApiException if fails to make API call
   */
  public Job getJob(String projectId, String jobId, List<JobOptField> optFields) throws ApiException {
    ApiResponse<Job> localVarResponse = getJobWithHttpInfo(projectId, jobId, optFields);
    return localVarResponse.getData();
  }

  /**
   * Get job information and its current state and progress (if available).
   * Get job information and its current state and progress (if available).
   * @param projectId project-space to run jobs on (required)
   * @param jobId of the job to be returned (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;Job&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Job> getJobWithHttpInfo(String projectId, String jobId, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getJobRequestBuilder(projectId, jobId, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getJob", localVarResponse);
        }
        return new ApiResponse<Job>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Job>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getJobRequestBuilder(String projectId, String jobId, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling getJob");
    }
    // verify the required parameter 'jobId' is set
    if (jobId == null) {
      throw new ApiException(400, "Missing the required parameter 'jobId' when calling getJob");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/projects/{projectId}/jobs/{jobId}"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()))
        .replace("{jobId}", ApiClient.urlEncode(jobId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Request job configuration with given name.
   * Request job configuration with given name.
   * @param name name of the job-config to return (required)
   * @param includeConfigMap if true the generic configmap will be part of the output (optional, default to false)
   * @return JobSubmission
   * @throws ApiException if fails to make API call
   */
  public JobSubmission getJobConfig(String name, Boolean includeConfigMap) throws ApiException {
    ApiResponse<JobSubmission> localVarResponse = getJobConfigWithHttpInfo(name, includeConfigMap);
    return localVarResponse.getData();
  }

  /**
   * Request job configuration with given name.
   * Request job configuration with given name.
   * @param name name of the job-config to return (required)
   * @param includeConfigMap if true the generic configmap will be part of the output (optional, default to false)
   * @return ApiResponse&lt;JobSubmission&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<JobSubmission> getJobConfigWithHttpInfo(String name, Boolean includeConfigMap) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getJobConfigRequestBuilder(name, includeConfigMap);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getJobConfig", localVarResponse);
        }
        return new ApiResponse<JobSubmission>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<JobSubmission>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getJobConfigRequestBuilder(String name, Boolean includeConfigMap) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling getJobConfig");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/job-configs/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "includeConfigMap";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("includeConfigMap", includeConfigMap));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Request all available job configurations
   * Request all available job configurations
   * @param includeConfigMap if true the generic configmap will be part of the output (optional, default to false)
   * @return List&lt;JobSubmission&gt;
   * @throws ApiException if fails to make API call
   */
  public List<JobSubmission> getJobConfigs(Boolean includeConfigMap) throws ApiException {
    ApiResponse<List<JobSubmission>> localVarResponse = getJobConfigsWithHttpInfo(includeConfigMap);
    return localVarResponse.getData();
  }

  /**
   * Request all available job configurations
   * Request all available job configurations
   * @param includeConfigMap if true the generic configmap will be part of the output (optional, default to false)
   * @return ApiResponse&lt;List&lt;JobSubmission&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<JobSubmission>> getJobConfigsWithHttpInfo(Boolean includeConfigMap) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getJobConfigsRequestBuilder(includeConfigMap);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getJobConfigs", localVarResponse);
        }
        return new ApiResponse<List<JobSubmission>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<JobSubmission>>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getJobConfigsRequestBuilder(Boolean includeConfigMap) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/job-configs";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "includeConfigMap";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("includeConfigMap", includeConfigMap));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Get job information and its current state and progress (if available).
   * Get job information and its current state and progress (if available).
   * @param projectId project-space to run jobs on (required)
   * @param page Zero-based page index (0..N) (optional, default to 0)
   * @param size The size of the page to be returned (optional, default to 20)
   * @param sort Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return PageJob
   * @throws ApiException if fails to make API call
   */
  public PageJob getJobs(String projectId, Integer page, Integer size, List<String> sort, List<JobOptField> optFields) throws ApiException {
    ApiResponse<PageJob> localVarResponse = getJobsWithHttpInfo(projectId, page, size, sort, optFields);
    return localVarResponse.getData();
  }

  /**
   * Get job information and its current state and progress (if available).
   * Get job information and its current state and progress (if available).
   * @param projectId project-space to run jobs on (required)
   * @param page Zero-based page index (0..N) (optional, default to 0)
   * @param size The size of the page to be returned (optional, default to 20)
   * @param sort Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. (optional
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;PageJob&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<PageJob> getJobsWithHttpInfo(String projectId, Integer page, Integer size, List<String> sort, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getJobsRequestBuilder(projectId, page, size, sort, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getJobs", localVarResponse);
        }
        return new ApiResponse<PageJob>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<PageJob>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getJobsRequestBuilder(String projectId, Integer page, Integer size, List<String> sort, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling getJobs");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/projects/{projectId}/jobs"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "page";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("page", page));
    localVarQueryParameterBaseName = "size";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("size", size));
    localVarQueryParameterBaseName = "sort";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "sort", sort));
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Add new job configuration with given name.
   * Add new job configuration with given name.
   * @param name name of the job-config to add (required)
   * @param jobSubmission to add (required)
   * @param overrideExisting  (optional, default to false)
   * @return String
   * @throws ApiException if fails to make API call
   */
  public String postJobConfig(String name, JobSubmission jobSubmission, Boolean overrideExisting) throws ApiException {
    ApiResponse<String> localVarResponse = postJobConfigWithHttpInfo(name, jobSubmission, overrideExisting);
    return localVarResponse.getData();
  }

  /**
   * Add new job configuration with given name.
   * Add new job configuration with given name.
   * @param name name of the job-config to add (required)
   * @param jobSubmission to add (required)
   * @param overrideExisting  (optional, default to false)
   * @return ApiResponse&lt;String&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<String> postJobConfigWithHttpInfo(String name, JobSubmission jobSubmission, Boolean overrideExisting) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = postJobConfigRequestBuilder(name, jobSubmission, overrideExisting);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("postJobConfig", localVarResponse);
        }
        // for plain text response
        if (localVarResponse.headers().map().containsKey("Content-Type") &&
                "text/plain".equalsIgnoreCase(localVarResponse.headers().map().get("Content-Type").get(0).split(";")[0].trim())) {
          java.util.Scanner s = new java.util.Scanner(localVarResponse.body()).useDelimiter("\\A");
          String responseBodyText = s.hasNext() ? s.next() : "";
          return new ApiResponse<String>(
                  localVarResponse.statusCode(),
                  localVarResponse.headers().map(),
                  responseBodyText
          );
        } else {
            throw new RuntimeException("Error! The response Content-Type is supposed to be `text/plain` but it's not: " + localVarResponse);
        }
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder postJobConfigRequestBuilder(String name, JobSubmission jobSubmission, Boolean overrideExisting) throws ApiException {
    // verify the required parameter 'name' is set
    if (name == null) {
      throw new ApiException(400, "Missing the required parameter 'name' when calling postJobConfig");
    }
    // verify the required parameter 'jobSubmission' is set
    if (jobSubmission == null) {
      throw new ApiException(400, "Missing the required parameter 'jobSubmission' when calling postJobConfig");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/job-configs/{name}"
        .replace("{name}", ApiClient.urlEncode(name.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "overrideExisting";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("overrideExisting", overrideExisting));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "text/plain");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(jobSubmission);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Import ms/ms data in given format from local filesystem into the specified project
   * Import ms/ms data in given format from local filesystem into the specified project.  The import will run in a background job  Possible formats (ms, mgf, cef, msp, mzML, mzXML, project-space)  &lt;p&gt;
   * @param projectId project-space to import into. (required)
   * @param importLocalFilesSubmission configuration of the job that will be submitted (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return Job
   * @throws ApiException if fails to make API call
   */
  public Job startImportFromPathJob(String projectId, ImportLocalFilesSubmission importLocalFilesSubmission, List<JobOptField> optFields) throws ApiException {
    ApiResponse<Job> localVarResponse = startImportFromPathJobWithHttpInfo(projectId, importLocalFilesSubmission, optFields);
    return localVarResponse.getData();
  }

  /**
   * Import ms/ms data in given format from local filesystem into the specified project
   * Import ms/ms data in given format from local filesystem into the specified project.  The import will run in a background job  Possible formats (ms, mgf, cef, msp, mzML, mzXML, project-space)  &lt;p&gt;
   * @param projectId project-space to import into. (required)
   * @param importLocalFilesSubmission configuration of the job that will be submitted (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;Job&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Job> startImportFromPathJobWithHttpInfo(String projectId, ImportLocalFilesSubmission importLocalFilesSubmission, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = startImportFromPathJobRequestBuilder(projectId, importLocalFilesSubmission, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("startImportFromPathJob", localVarResponse);
        }
        return new ApiResponse<Job>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Job>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder startImportFromPathJobRequestBuilder(String projectId, ImportLocalFilesSubmission importLocalFilesSubmission, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling startImportFromPathJob");
    }
    // verify the required parameter 'importLocalFilesSubmission' is set
    if (importLocalFilesSubmission == null) {
      throw new ApiException(400, "Missing the required parameter 'importLocalFilesSubmission' when calling startImportFromPathJob");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/{projectId}/jobs/import-from-local-path"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(importLocalFilesSubmission);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
   * Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
   * @param projectId project-space to import into. (required)
   * @param importStringSubmission configuration of the job that will be submitted (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return Job
   * @throws ApiException if fails to make API call
   */
  public Job startImportFromStringJob(String projectId, ImportStringSubmission importStringSubmission, List<JobOptField> optFields) throws ApiException {
    ApiResponse<Job> localVarResponse = startImportFromStringJobWithHttpInfo(projectId, importStringSubmission, optFields);
    return localVarResponse.getData();
  }

  /**
   * Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
   * Import ms/ms data from the given format into the specified project-space  Possible formats (ms, mgf, cef, msp, mzML, mzXML)
   * @param projectId project-space to import into. (required)
   * @param importStringSubmission configuration of the job that will be submitted (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;Job&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Job> startImportFromStringJobWithHttpInfo(String projectId, ImportStringSubmission importStringSubmission, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = startImportFromStringJobRequestBuilder(projectId, importStringSubmission, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("startImportFromStringJob", localVarResponse);
        }
        return new ApiResponse<Job>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Job>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder startImportFromStringJobRequestBuilder(String projectId, ImportStringSubmission importStringSubmission, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling startImportFromStringJob");
    }
    // verify the required parameter 'importStringSubmission' is set
    if (importStringSubmission == null) {
      throw new ApiException(400, "Missing the required parameter 'importStringSubmission' when calling startImportFromStringJob");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/{projectId}/jobs/import-from-string"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(importStringSubmission);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Start computation for given compounds and with given parameters.
   * Start computation for given compounds and with given parameters.
   * @param projectId project-space to run jobs on (required)
   * @param jobSubmission configuration of the job that will be submitted of the job to be returned (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return Job
   * @throws ApiException if fails to make API call
   */
  public Job startJob(String projectId, JobSubmission jobSubmission, List<JobOptField> optFields) throws ApiException {
    ApiResponse<Job> localVarResponse = startJobWithHttpInfo(projectId, jobSubmission, optFields);
    return localVarResponse.getData();
  }

  /**
   * Start computation for given compounds and with given parameters.
   * Start computation for given compounds and with given parameters.
   * @param projectId project-space to run jobs on (required)
   * @param jobSubmission configuration of the job that will be submitted of the job to be returned (required)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;Job&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Job> startJobWithHttpInfo(String projectId, JobSubmission jobSubmission, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = startJobRequestBuilder(projectId, jobSubmission, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("startJob", localVarResponse);
        }
        return new ApiResponse<Job>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Job>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder startJobRequestBuilder(String projectId, JobSubmission jobSubmission, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling startJob");
    }
    // verify the required parameter 'jobSubmission' is set
    if (jobSubmission == null) {
      throw new ApiException(400, "Missing the required parameter 'jobSubmission' when calling startJob");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/projects/{projectId}/jobs"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(jobSubmission);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Start computation for given compounds and with parameters from a stored job-config.
   * Start computation for given compounds and with parameters from a stored job-config.
   * @param projectId project-space to run jobs on (required)
   * @param jobConfigName name if the config to be used (required)
   * @param requestBody compound ids to be computed (required)
   * @param recompute enable or disable recompute. If null the stored value will be used. (optional)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return Job
   * @throws ApiException if fails to make API call
   */
  public Job startJobFromConfig(String projectId, String jobConfigName, List<String> requestBody, Boolean recompute, List<JobOptField> optFields) throws ApiException {
    ApiResponse<Job> localVarResponse = startJobFromConfigWithHttpInfo(projectId, jobConfigName, requestBody, recompute, optFields);
    return localVarResponse.getData();
  }

  /**
   * Start computation for given compounds and with parameters from a stored job-config.
   * Start computation for given compounds and with parameters from a stored job-config.
   * @param projectId project-space to run jobs on (required)
   * @param jobConfigName name if the config to be used (required)
   * @param requestBody compound ids to be computed (required)
   * @param recompute enable or disable recompute. If null the stored value will be used. (optional)
   * @param optFields set of optional fields to be included. Use &#39;none&#39; only to override defaults. (optional
   * @return ApiResponse&lt;Job&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Job> startJobFromConfigWithHttpInfo(String projectId, String jobConfigName, List<String> requestBody, Boolean recompute, List<JobOptField> optFields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = startJobFromConfigRequestBuilder(projectId, jobConfigName, requestBody, recompute, optFields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("startJobFromConfig", localVarResponse);
        }
        return new ApiResponse<Job>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Job>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder startJobFromConfigRequestBuilder(String projectId, String jobConfigName, List<String> requestBody, Boolean recompute, List<JobOptField> optFields) throws ApiException {
    // verify the required parameter 'projectId' is set
    if (projectId == null) {
      throw new ApiException(400, "Missing the required parameter 'projectId' when calling startJobFromConfig");
    }
    // verify the required parameter 'jobConfigName' is set
    if (jobConfigName == null) {
      throw new ApiException(400, "Missing the required parameter 'jobConfigName' when calling startJobFromConfig");
    }
    // verify the required parameter 'requestBody' is set
    if (requestBody == null) {
      throw new ApiException(400, "Missing the required parameter 'requestBody' when calling startJobFromConfig");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/api/projects/{projectId}/jobs/from-config"
        .replace("{projectId}", ApiClient.urlEncode(projectId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "jobConfigName";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("jobConfigName", jobConfigName));
    localVarQueryParameterBaseName = "recompute";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("recompute", recompute));
    localVarQueryParameterBaseName = "optFields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "optFields", optFields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(requestBody);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
